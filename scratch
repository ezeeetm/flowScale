



'''




def HeartBeat ( stateTable, stackId ):
    now = int(time.time())
    print("Heartbeat for stack %s @ %s epoch time") % ( stackId, now )
    response = stateTable.update_item(
        Key={
            'stackId': stackId
        },
        UpdateExpression="set lastHeartBeatTime = :lh",
        ExpressionAttributeValues={
            ':lh': now
        },
        ReturnValues="UPDATED_NEW"
    )
    print("UpdateItem succeeded: %s") % ( response )

def HealthCheck ( stateTable, config ):
    healthCheckTimeOut = config['globalConfig']['healthCheckTimeOut']
    stacks = config['stackConfigs']
    for stack in stacks:
        response = stateTable.get_item(
            Key={
                'stackId': stack
            }
        )
        lastHeartBeatTime = response['Item']['lastHeartBeatTime']
        timeSinceLastHeartBeat = now = int(time.time()) - lastHeartBeatTime
        if timeSinceLastHeartBeat > healthCheckTimeOut:
            print('DO HEALTHCHECKTIMEOUT STUFF HERE: stack: %s timeSinceLastHeartBeat: %s > healthCheckTimeOut of %s') % ( stack, timeSinceLastHeartBeat, healthCheckTimeOut)

def UpdateStack ( stackId, stateTable, scenario ):






    # dynamo connection object, do this at app start only, not for each operation. Creates admin table to manage state, if it does not exist

    if eventType == 'heartbeat':
        HeartBeat ( stateTable, stackId )

    elif eventType == 'healthcheck':
        HealthCheck ( stateTable, config )

    elif eventType == 'update':

        UpdateStack ( stackId, stateTable, scenario )

    else:
        raise ValueError('This should never happen. Ensure \'event\' parameter = \'heartbeat\' | \'healthcheck\' | \'update\'' )


    if debug == True:
        vals = {
            'region': region,
            'stack': stack,
            'uid': uid,
            'eventType': eventType,
            'region': region,
            'stackId': stackId
        }
        Debug ( vals )

        if eventType == 'update':
            vals = {
                'scenarioId': scenarioId,
                'scenario': scenario
            }
            Debug ( vals )
            for changeGroup in scenario:
                print("changeGroup: %s") % ( changeGroup )

'''
#todo
scheduled call with type heartbeat check if over configured threshold, change scenario to 'idle'

ensure request to change scenarios is ignored when already in that scenario

refactor: pass config around, debug smarter, rename objects?

test to ensure each stack has an idle scenario, alert when not true
function to ensure all tables have a workflow idle rule, with exclude list, SNS alert when this is not the case
adding new stacks to config should add them to the stateTable, currently you have to delete the table and repopulate it
throughput currently adjusted table by table, including indexes. Add functionality to break out indexes explicitly by name, and also by regex
'''
'''
